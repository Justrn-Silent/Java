package 多线程;
/*
线程状态
-------------------------------------------------------------------------------------------------------------------------
Java线程从创建到销毁的全生命周期状态流转逻辑
核心可拆解为「新生→就绪→运行→死亡」的主线，及「运行→阻塞→就绪」的分支（阻塞含3种子状态）。
以下是流程总结：  
 1. 新生状态 → 就绪状态  
触发条件：线程对象被`new Thread()`创建后，调用 `start()` 方法。  
含义：线程刚被实例化（“新生”），调用`start()`后进入“等待CPU调度”的**就绪队列。  
2. 就绪状态 ↔ 运行状态  
就绪→运行：线程获得CPU执行权（JVM调度器分配时间片），开始执行`run()`方法。  
运行→就绪：线程失去CPU执行权（如时间片用完、被更高优先级线程抢占），回到就绪队列等待下次调度。  
3. 运行状态 → 死亡状态  
触发条件：run()`方法正常执行完毕（或因未捕获异常终止）。  
含义：线程生命周期结束，无法再回到其他状态。  
4. 运行状态 → 阻塞状态（含3种子状态）  
运行时，线程因“资源等待/锁竞争”暂时放弃CPU，进入阻塞状态（细分为同步阻塞、等待阻塞、其他阻塞）：  
同步阻塞：  
触发：运行中遇到`synchronized`关键字，竞争锁失败（锁被其他线程占用）。  
唤醒：当锁被释放（其他线程退出同步块），回到**就绪状态。  
等待阻塞：  
触发：运行中调用`wait()`方法（需在同步块内），线程主动进入等待。  
唤醒：被同锁对象的`notify()`/`notifyAll()`唤醒后，回到**就绪状态。  
其他阻塞：  
触发：运行中调用`sleep()`、`join()`、IO操作（如网络/文件读写）等。  
唤醒：`sleep()`时间到、`join()`的目标线程执行完毕、IO操作完成后，回到就绪状态。  

关键逻辑提炼  
线程“生老病死”主线：`new`（新生）→`start()`（就绪）→CPU调度（运行）→`run()`结束（死亡）。  
阻塞是“运行→等待资源→重新就绪”的**临时状态，需通过锁释放、唤醒通知、资源就绪等条件回到就绪队列，重新竞争CPU
-------------------------------------------------------------------------------------------------------------------------
Java线程从创建到销毁的全生命周期状态流转逻辑
可按「新生→就绪→运行→死亡 主线 + 运行→阻塞→就绪 分支」详细拆解： 
 
 一、新生状态（New）  
 触发条件：
 通过 `new Thread()` 显式创建线程对象（如代码 `Thread t = new Thread()`）。  
 状态含义：
 线程对象被JVM分配内存、初始化属性（如线程名、优先级），但未参与CPU调度（没有执行代码的资格）。  
 图中注释：「
 线程对象一旦创建就进入了新生状态」—— 这是线程生命周期的起点，仅代表“对象存在”，未激活调度逻辑。
   
 二、就绪状态（Runnable）  
 触发条件：
 调用线程对象的 `start()` 方法（如 `t.start()`）。  
 状态含义：
 线程进入「等待CPU调度」的队列（就绪队列），具备被CPU选中执行的资格，但尚未真正开始执行代码。  
 图中注释关键细节：
 「当调用start()方法，线程立即进入就绪状态
 但是不意味着立即调度执行」—— 强调 `start()` 的作用是把线程送入“候选池”，而非“立即执行代码”。
 CPU调度权由JVM（或操作系统）的调度器决定，何时执行完全不确定。
   
 三、运行状态（Running）  
 触发条件：
 就绪状态下，CPU调度器为线程分配时间片（即线程被选中执行）。  
 状态含义：
 线程开始执行 `run()` 方法中的代码，是真正“干活”的阶段（业务逻辑落地）。  
 图中注释补充：
 「进入运行状态，线程才真正执行线程体的代码块」—— 只有到“运行状态”，线程的核心逻辑（`run()` 内的代码）才会被执行。  


四、死亡状态（Dead）  
触发条件：
运行状态下，`run()` 方法正常执行完毕（代码逻辑走完），或因未捕获异常强制终止（如空指针、数组越界等未处理异常）。  
状态含义：
线程生命周期结束，JVM回收其资源，线程彻底“消亡”。  
图中注释关键限制：
「一旦进入死亡状态，不能再调用start()再次启动线程」—— 死亡是线程的终态，线程对象无法“复活”。若对已死亡的线程调用 `start()`，会抛出 `IllegalThreadStateException` 异常。  


五、阻塞状态（Blocked）：运行状态的分支流转  
触发条件（“导致阻塞的事件”）：  
调用 `Thread.sleep(long millis)`：
线程主动休眠指定时间（休眠时不释放锁，仅暂停执行）。  
调用 `Object.wait()`：
在 `synchronized` 同步块/方法中调用，线程释放锁并进入等待（需配合 `notify()`/`notifyAll()` 唤醒）。  
同步锁定竞争失败：
进入 `synchronized` 修饰的代码块/方法时，锁已被其他线程占用。  
其他IO阻塞（图中未明确提及，属常见场景）：
如网络请求、文件读写等待（需等IO资源就绪）。  
状态含义：
线程暂停执行（代码不再向下运行），进入“等待资源/信号”的暂停态。  
阻塞解除后的流转：
阻塞状态 → 就绪状态（图中“阻塞解除”箭头）—— 阻塞原因消除后，线程回到就绪队列重新等待CPU调度（不会直接回到运行状态，必须再经过调度环节）。  
图中注释补充：
「当调用sleep()、wait()或同步锁定时，线程进入阻塞状态……阻塞事件解除后，重新进入就绪状态，等待CPU调度执行才进入运行状态」—— 强调阻塞是「暂停→等待→重新排队」的过程，解除后需再次竞争CPU才能执行。  


六、状态流转的核心逻辑链（结合箭头方向）  
`新生(new)` →（调用`start()`）→ `就绪` →（CPU调度）→ `运行` →（两种分支）→  
分支1：
`运行` →（`run()`执行完毕/异常终止）→ `死亡(dead)`；  
分支2：`
运行` →（触发阻塞事件：sleep/wait/锁竞争等）→ `阻塞` →（阻塞解除）→ `就绪` →（CPU调度）→ `运行`（循环，直到`run()`结束）。  


 关键细节强化（图中注释的深层解读）  
1. `start()` 的本质：激活线程进入调度队列，而非“立即执行代码”—— 新手易误解`start()`是“直接跑代码”，实际是先入“候选池”等CPU。  
2. 阻塞的“被动性”：线程在运行时因“等资源/等信号”被迫暂停，不是主动放弃CPU（区别于`yield()`，图中未提及，暂不延伸）。  
3. 死亡的“不可逆性”：线程死了就无法复活，哪怕对象还在，调用`start()`也会报错—— 这是线程与普通对象的本质区别（普通对象可重复使用，线程对象是“一次性”的执行载体）。  


线程在“创建→等待调度→执行代码→暂停等待→重新排队→结束”全流程中的状态切换条件、各状态的含义，以及阻塞场景的细分与恢复逻辑~
----------------------------------------------------------------------------------------------------------------------------
线程方法:
sleep()
使线程停止运行一段时间，将处于阻塞状态
如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行!
join()
阻塞指定线程等到另一个线程完成以后再继续执行。
yield()
让当前正在执行线程暂停，不是阻塞线程，而是将线程转入就绪状态;
调用了yield方法之后，如果没有其他等待执行的线程，此时当前线程就会马上恢复执行!
setDaemon()
可以将指定的线程设置成后台线程,守护线程:
创建用户线程的线程结束时，后台线程也随之消亡
只能在线程启动之前把它设为后台线程
setPriority(int newPriority)getPriority()
·线程的优先级代表的是概率
范围从1到10，默认为5
stop()停止线程
不推荐使用
 */
