package 面向对象_继承;
/*
super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性
使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。
若是构造方法的第一行代码没有显式的调用super(..)或者this(..);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。
----------------------------------------
·构造方法调用顺序:
构造方法第一句总是:super(.)来调用父类对应的构造方法。
所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止
注：静态初始化块调用顺序，与构造方法调用顺序一样，不再重复。
*/
class 父类01{
	 父类01(int a) {
		System.out.println("父类被调用,父类构造方法传参为："+a);
	}
}
class 子类01 extends 父类01{
	 子类01() {
		//super();//这里无法隐式调用，因为父类构造方法有参数
		super(0);
		System.out.println("子类被调用");
	}
}
public class super关键字_有参继承树追溯 {
	public static void main(String[] args) {
		new 子类01();//所以会先执行父类构造方法紧接着再子类的构造方法
	}
	
}
/*
 关于super()的运行逻辑：
  首先创建子类的实例，执行子类构造方法显式调用super到父类的构造方法，接着父类构造方法隐式调用super到Object类的构造方法
  如何才开始调用JVM虚拟机进行初始化非静态属性：Object---->父类------>子类
  (子类其实是父类的实例)
  [JVM负责对象的内存空间分配和初始化，而super关键字是用来引导JVM调用父类构造方法，确保父类部分得到正确初始化，并在继承关系中建立联系]
  [这是 Java 继承机制]
  最后才是正是运行子类的代码
  有递归的意思
 */
