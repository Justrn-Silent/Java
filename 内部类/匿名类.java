package 内部类;
/*
适合那种只需要使用一次的类。比如:键盘监听操作等等。
语法：
new 父类构造器(实参类表)实现接口(){
	//匿名内部类类体!
	}
	
*/
/*----------------------------------------------------------------------------------------------------------------------------*/
abstract class Fireworks {
    abstract void boom();
}
public class 匿名类 {
	public static void main(String[] args) {
	 new Fireworks() {
         void boom() {
             System.out.println("烟花爆炸");
         }
     }.boom();
}
}
/*展开式：
abstract class Fireworks {
    abstract void boom();
}

public class 匿名类 {
	public static void main(String[] args) {
		class 匿名类&1 implements Fireworks {
         void boom() {
             System.out.println("烟花爆炸");
         }
        }
        Fireworks s =new 匿名类&1();
        s,boom();
    }
}

*/
/*----------------------------------------------------------------------------------------------------------------------------*/
/*
在这个例子中，虽然 Fireworks 是一个抽象类，但是通过以下步骤创建了一个匿名内部类的实例：
匿名内部类：new Fireworks() 这行代码创建了一个匿名内部类，它是 Fireworks 类的一个子类。
			由于它是匿名类，所以它没有自己的名字，因此我们无法在代码中引用它。
实现抽象方法：在这个匿名内部类中，我们提供了一个 boom 方法的实现，这是 Fireworks 抽象类中声明的抽象方法。
			创建实例：由于匿名内部类是 Fireworks 类的子类并且实现了其所有抽象方法，因此它不再是抽象的，可以被实例化。
new 关键字在这里用来创建这个匿名内部类的实例。

以下是为什么可以这样做的几个原因：
即时实现：这种用法允许在需要的时候立即定义一个类并创建其实例。这在某些情况下非常有用，比如在事件监听器或回调函数中。
不需要显式命名：匿名内部类不需要一个名字，这在某些情况下可以节省代码空间，且使代码更加简洁。
隐藏实现细节：使用匿名内部类可以隐藏具体的实现并细节，因为它没有公共的类名，外部代码无法直接访问或继承它。
总结来说，尽管抽象类不能直接实例化，但通过创建其匿名内部类的子类并实现所有抽象方法，可以创建一个具体的实例。
这是Java中匿名内部类的一个典型用法。
*/